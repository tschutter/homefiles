#!/usr/bin/env python3

"""
Run multiple Python static checkers.

Reads ~/.pycheck if it exists, which looks like:

[DEFAULT]
max-line-length = 120
"""

import argparse
import configparser
import os
import pathlib
import re
import subprocess
import sys
import tempfile
import textwrap


def which(checker):
    """Determine if a checker is installed."""

    for path in os.environ["PATH"].split(os.pathsep):
        exe_file = os.path.join(path, checker)
        if os.path.isfile(exe_file) and os.access(exe_file, os.X_OK):
            return exe_file

    return None


def run_and_filter(pycheck_args, args, ignore=None):
    """Run a program and filter the output."""

    if pycheck_args.verbose:
        print(f"## {' '.join(args)}")

    stdout = subprocess.run(
        args,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        check=False,
        text=True
    ).stdout

    if ignore and pycheck_args.filter_output:
        re_ignore = re.compile(ignore)
        for line in stdout.split("\n")[:-1]:
            if not re_ignore.match(line):
                print(line)
    else:
        sys.stdout.write(stdout)


def run_flake8(pycheck_args, program, filename):
    """Run the flake8 checker."""

    args = [
        program,
        f"--max-line-length={pycheck_args.max_line_length}",
        filename
    ]
    run_and_filter(pycheck_args, args)


def run_pylint(pycheck_args, program, filename):
    """Run the pylint checker."""

    args = [
        program,
        "--reports=no",
        "--score=no",
        f"--max-line-length={pycheck_args.max_line_length}",
        filename
    ]
    ignore = r"^\*\*\*\*\*\*"  # "|--msg-template"
    run_and_filter(pycheck_args, args, ignore)


def run_pyflakes(pycheck_args, program, filename):
    """Run the pyflakes checker."""

    args = [program, filename]
    run_and_filter(pycheck_args, args)


def run_pycodestyle(pycheck_args, program, filename):
    """Run the pycodestyle checker."""

    # E202 whitespace before ')'
    # E501 line too long - cannot be suppressed per file
    args = [
        program,
        "--ignore=E202,E501",
        "--repeat",
        f"--max-line-length={pycheck_args.max_line_length}",  # ignored?
        filename,
    ]
    run_and_filter(pycheck_args, args)


def run_pydocstyle(pycheck_args, program, filename):
    """Run the pydocstyle checker."""

    # Use --match to allow for files without .py extension.
    args = [program, f"--match={filename}", filename]
    # Allow for "Main" function comment in main().
    # Not good.  Need to do multi-line ignores.
    ignore = (
        r"^.+:[0-9]+ in public function `main`:$|"
        r"^\s+D401: First line should be in imperative mood;"
        r" try rephrasing \(found 'Main'\)$"
    )
    run_and_filter(pycheck_args, args, ignore)


def run_pytype(pycheck_args, program, filename):
    """Run the pytype checker."""

    args = [program, "--no-cache", filename]
    ignore = (
        r"^Computing dependencies$|"
        r"^(ninja: Entering|Leaving) directory |"
        r"^\[1/1\] check |"
        r"^Analyzing 1 sources with [0-9]+ local dependencies$|"
        r"^Success: no errors found$"
    )
    run_and_filter(pycheck_args, args, ignore)


def run_pyright(pycheck_args, program, filename):
    """Run the pyright checker."""

    # Create a temporary config file (documented at
    # https://github.com/microsoft/pyright/blob/main/docs/configuration.md).
    config = textwrap.dedent("""
    {
        "pythonVersion": "3.9",
        "reportMissingParameterType": false,
        "reportUnknownArgumentType": false,
        "reportUnknownMemberType": false,
        "reportUnknownParameterType": false,
        "reportUnknownVariableType": false,
        "typeCheckingMode": "strict"
    }
    """)
    cfile_handle, cfile_name = tempfile.mkstemp(
        suffix=".json",
        prefix="pyrightconfig_"
    )
    try:
        try:
            os.write(cfile_handle, config.encode("utf-8"))
        finally:
            os.close(cfile_handle)

        args = [program, "--project", cfile_name, filename]
        ignore = (
            # comment out first line to debug config
            rf"Loading configuration file at {cfile_name}$|"
            r"^No configuration file found.$|"
            r"^No pyproject.toml file found.$|"
            r"^stubPath [^\ ]+ is not a valid directory.$|"
            r"^Assuming Python platform [^\ ]+$|"
            r"^Searching for source files$|"
            r"^Found [1-9][0-9]* source file$|"
            r"^0 errors, 0 warnings, 0 informations $|"
            r"^Completed in [0-9]+\.[0-9]+sec$|"
            r"Assuming Python version 3.[0-9]+$|"
            r"Auto-excluding \*\*/node_modules$|"
            r"Auto-excluding \*\*/__pycache__$|"
            r"Auto-excluding \*\*/\.\*$"
        )
        run_and_filter(pycheck_args, args, ignore)

    finally:
        os.remove(cfile_name)


def check_file(pycheck_args, filename):
    """Check a single file."""

    for checker in pycheck_args.checkers:
        program = which(checker)
        if program is None:
            print(f"## {checker} not installed")
            continue

        print(f"## {checker}")
        if checker in ["pyright", "pytype"] and not filename.endswith(".py"):
            # copy contents to temporary file
            tfile_handle, tfile_name = tempfile.mkstemp(
                suffix=".py",
                prefix=f"{filename}_",
                dir="."
            )
            try:
                try:
                    with open(filename, "rb") as pyfile:
                        contents = pyfile.read()
                        os.write(tfile_handle, contents)
                finally:
                    os.close(tfile_handle)

                KNOWN_CHECKERS[checker](pycheck_args, program, tfile_name)

            finally:
                os.remove(tfile_name)

        else:
            KNOWN_CHECKERS[checker](pycheck_args, program, filename)


KNOWN_CHECKERS = {
    "flake8": run_flake8,
    "pylint": run_pylint,
    "pyflakes": run_pyflakes,
    "pycodestyle": run_pycodestyle,
    "pydocstyle": run_pydocstyle,
    "pyright": run_pyright,
    "pytype": run_pytype
}


def main():
    """Main."""

    # Build default list of checkers.
    # [2021-06-25] pytype has gotten extremely slow
    default_checkers = ",".join(
        c for c in KNOWN_CHECKERS if c not in ["pytype"]
    )

    # Define arguments.
    arg_parser = argparse.ArgumentParser(
        description="Run multiple Python static checkers.",
        epilog="Reads ~/.pycheck if it exists for option defaults."
    )
    arg_parser.add_argument(
        "--checkers",
        default=default_checkers,
        help="checkers to run (default=%(default)s)"
    )
    arg_parser.add_argument(
        "--list-checkers",
        action="store_true",
        help="list known checkers and exit"
    )
    arg_parser.add_argument(
        "--max-line-length",
        metavar="N",
        default=80,
        help="maximum length of any line"
    )
    arg_parser.add_argument(
        "--no-filter",
        dest="filter_output",
        action="store_false",
        default=True,
        help="do not filter noise; use for debugging pycheck"
    )
    arg_parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="show command line for each checker"
    )
    arg_parser.add_argument(
        "files",
        metavar="file",
        nargs="+",
        help="file to check"
    )

    # Override defaults from config file.
    config_file = os.path.join(pathlib.Path.home(), ".pycheck")
    if os.path.isfile(config_file):
        config = configparser.ConfigParser()
        config.read(config_file)
        items = {k.replace("-", "_"): v for k, v in config.items("DEFAULT")}
        arg_parser.set_defaults(**items)

    # Parse and validate command line arguments.
    args = arg_parser.parse_args()
    if args.list_checkers:
        print(",".join(KNOWN_CHECKERS))
        return 0
    args.checkers = args.checkers.split(",")
    for checker in args.checkers:
        if checker not in KNOWN_CHECKERS:
            print(f"error: unknown checker '{checker}'")
            return 1

    # Check if specified files exist.
    file_not_found = False
    for filename in args.files:
        if not os.path.isfile(filename):
            print(f"error: {filename} not found")
            file_not_found = True
    if file_not_found:
        return 1

    # Check each file.
    first = True
    for filename in args.files:
        if not first:
            print("")
        else:
            first = False
        print(f"### {filename}")
        check_file(args, filename)

    return 0


if __name__ == "__main__":
    main()
